---
title: "Micromouse ğŸ­ğŸ’¡"
summary: "Autonomer Labyrinth-Roboter mit Sensorsteuerung, PD-Regelung und Maze-Solving-Algorithmen â€“ alles handcoded."

publishedAt: "2023-04-08"
updatedAt: "2023-08-10"
readingTime: "5 min"

categories:
  - "Robotics"
  - "Embedded Systems"
  - "AI"

tag:
  - "Micromouse"
  - "Maze Solving"
  - "PD Control"
  - "C++"
  - "Microcontroller"

keywords:
  - "Autonomer Roboter"
  - "Micromouse AI"
  - "Maze Solving Algorithm"
  - "PD Steuerung"
  - "Embedded Entwicklung"

status: "published"

images:
  - "/images/projects/Micromouse/Micromouse1.jpeg"
  - "/images/projects/Micromouse/Micromouse2.jpeg"
  - "/images/projects/Micromouse/Micromouse3.jpeg"
  - "/images/projects/Micromouse/Micromouse4.jpeg"
  - "/images/projects/Micromouse/Micromouse5.jpeg"

authors: 'me'
---

# Micromouse ğŸ­ğŸ’¡

**Ein Mini-Roboter mit maximalem Ehrgeiz â€“ und mindestens genauso vielen Bugs.**

Micromouse ist ein Wettbewerb, bei dem kleine autonome Roboter â€“ liebevoll â€MÃ¤useâ€œ genannt â€“ ein 16Ã—16-Zellen groÃŸes Labyrinth ganz ohne Hilfe durchqueren. Das Ziel: SchnellstmÃ¶glich vom Start ins Zentrum.

Jede Zelle misst 180â€¯mm, die WÃ¤nde sind 50â€¯mm hoch. Klingt easy?

> "Wie schwer kannâ€™s sein?" â€“ 300 Stunden spÃ¤ter...

## ğŸ§  Was muss so eine Maus kÃ¶nnen?

- WÃ¤nde erkennen (IR-Sensoren in alle Richtungen â€“ Batman wÃ¤re neidisch)
- Wissen, wo sie ist (ohne GPS oder Google Maps)
- Eine Karte vom Labyrinth bauen
- Den kÃ¼rzesten Pfad zum Ziel finden
- Alles mÃ¶glichst schnell, effizient â€“ und ohne sich selbst umzubringen

## ğŸ§° Mein Part: Full Stack Roboter-Dompteur

Ich war der Typ, der alles programmiert hat. Low-Level-Magic bis zur Maze-Logik. Vom ersten ADC-Wert bis zur finalen Kurvenfahrt.

## ğŸ”Œ Sensoren & ADC

Erstmal hab ich IR-Sensoren angebunden â€“ fÃ¼r WÃ¤nde, die sich _nicht_ selbst melden.

```c
void adc_init() {
    ADMUX  = (1 << REFS0);
    ADCSRA = (1 << ADEN) | (1 << ADPS1) | (1 << ADPS0);
}

uint16_t read_adc(uint8_t channel) {
    ADMUX = (ADMUX & 0xF0) | (channel & 0x0F);
    ADCSRA |= (1 << ADSC);
    while (ADCSRA & (1 << ADSC));
    return ADC;
}
```

> ADC: â€œIch sehe was, was du nicht siehst â€“ und es ist... eine Wand.â€

## âš™ï¸ Motorsteuerung mit PWM

Zwei DC-Motoren, ein Motortreiber â€“ und die Hoffnung, dass nichts abraucht.

```c
void pwm_init() {
    DDRD |= (1 << PD6) | (1 << PD5);
    TCCR0A = (1 << COM0A1) | (1 << COM0B1) | (1 << WGM01) | (1 << WGM00);
    TCCR0B = (1 << CS01);
}

void set_motor_speed(uint8_t left, uint8_t right) {
    OCR0A = left;
    OCR0B = right;
}
```

> PWM: Die Kunst, Motoren dazu zu bringen, _genau so schnell_ zu drehen wie du willst â€“ und _nicht schneller als dein Akku verkraftet_.

## ğŸ¯ PD-Regelung â€“ Geradeaus ist auch eine Richtung

Ohne Regelung fuhr die Maus wie betrunken durch den Parcours. Mit PD-Controller blieb sie auf Spur:

```c
int16_t pd_controller(int16_t error) {
    static int16_t prev_error = 0;
    const int16_t Kp = 8;
    const int16_t Kd = 4;

    int16_t derivative = error - prev_error;
    prev_error = error;

    return (Kp * error) + (Kd * derivative);
}
```

> Technisch korrekt, gefÃ¼hlt wie Power-Steering fÃ¼r Roboter.

## ğŸ§­ Maze-Solving: Right-Wall-Follower

Einfach, effektiv, funktioniert meistens:

```c
void follow_right_wall() {
    uint16_t front = read_adc(0);
    uint16_t right = read_adc(1);
    uint16_t left  = read_adc(2);

    if (right > 200) {
        if (front > 200) {
            turn_left();
        } else {
            drive_forward();
        }
    } else {
        turn_right();
    }
}
```

> Logik-Level: â€Ich halt mich rechts, Bruder.â€œ ğŸ’

## ğŸš— Bewegungsfunktionen

Basic ManÃ¶ver, aber solide. Wenn man weiÃŸ, wieâ€™s sich dreht, fÃ¤hrt man besser.

```c
void drive_forward() {
    set_motor_speed(200, 200);
}

void turn_left() {
    set_motor_speed(100, 200);
    _delay_ms(300);
}

void turn_right() {
    set_motor_speed(200, 100);
    _delay_ms(300);
}
```

> Delay ist kein echtes Timing â€“ aber hey, es funktioniert (meistens).

## ğŸ” Main Loop

Der Loop, in dem alles passiert. Nicht hÃ¼bsch, aber effektiv.

```c
int main(void) {
    adc_init();
    pwm_init();

    while (1) {
        follow_right_wall();
    }
}
```

> "While(1)": Wo Embedded-Leute leben. Und sterben. Und debuggen.

## ğŸ Ergebnis: Sieger der Herzen (und des Hochschulwettbewerbs)

Unsere Maus war nicht nur schnell, sie war prÃ¤zise. Sie war **die schnellste Maus im Rennen** â€“ trotz minimalistischer Strategie.

âœ… Kein Crash
âœ… Kein Kabelbrand
âœ… Kein Verirren
âœ… Viel Applaus (und ein bisschen Stolz)

## ğŸ§ª NÃ¤chstes Level (a.k.a. Das Upgrade, wenn duâ€™s ernst meinst)

- Flood-Fill fÃ¼r smarteres Mapping
- Gyro fÃ¼r Drehkontrolle
- Encoder fÃ¼r echte Distanzmessung
- OLED-Display: â€Wall ahead! Panic now.â€œ
- Bluetooth/UART Logging

## ğŸ“¸ Projektgalerie

![Micromouse](/images/projects/Micromouse/Micromouse.mp4)

> Hier kÃ¶nnte dein Roboter stylish durchs Maze fahren.

## ğŸ’¬ Fazit

Micromouse ist kein AnfÃ¤ngerprojekt. Es ist Embedded-Ritterschlag.
Wenn duâ€™s baust, lernst du alles â€“ und verlierst vielleicht deinen Verstand kurzzeitig beim Debuggen.

Aber dann siehst du ihn fahren. SelbststÃ¤ndig. Im Ziel.
Und denkst dir:

> **â€Du bist meine kleine, nervige, piepende SchÃ¶pfung â€“ und ich bin stolz auf dich.â€œ**
